{"0": {
    "doc": "Develop with Redis",
    "title": "Develop with Redis",
    "content": "레디스 개발에 대해 알아본다. Quick starts . 빠르게 레디스를 시작하는 가이드 . Connect to Redis . 유저 인터페이스와 클라이언트 라이브러리를 사용하는 방법 . Understand Redis data types . 레디스가 지원하는 데이터 타입 오버뷰 . Interact with data in Redis . 쿼리, 트리거 함수, 트랜젝션, pub/sub을 사용해서 레디스의 데이터와 상호작용하는 방법 . User Redis . 레디스 개발자 가이드 . Redis reference . 명세, 프로토콜 . ",
    "url": "/docs/01_redis/00.preface/",
    
    "relUrl": "/docs/01_redis/00.preface/"
  },"1": {
    "doc": "Preface",
    "title": "Preface",
    "content": "이 문서는 PostgreSQL의 공식 문서이다. PostgreSQL의 개발자와 다른 기여자들이 작성하였으며 PostgreSQL 소프트웨어 개발과 병행하여 진행되었다. PostgreSQL에서 공식적으로 지원하는 현재 버전의 모든 기능들을 설명한다. PostgreSQL에 관한 많은 양의 정보를 관리하기위해 이 문서는 여러 파트로 이루어져 있다. 각각의 파트는 다양한 단계의 경험을 가지고 있는 사용자 또는 다양한 사용자 단계를 대상으로 이루어져있다. | Part1은 신규 유저를 위한 간단한 소개이다. | Part2는 데이터 타입, 함수, 유저 레벨의 성능 튜닝을 포함하는 SQL 쿼리 언어 환경에 대해 설명한다. 모든 PostgreSQL 사요자는 이 파트를 반드시 읽어야한다. | Part3 서버 설치와 관리에 대해서 셜명한다. 프라이빗 또는 다른 환경에서 PostgreSQL 서버를 구동하는 모든 사람들은 이 파트를 읽어야 한다. | Part4는 PostgreSQL의 클라이언트 프로그램의 프로그래밍 인터페이스에 대해서 설명한다. | Part5는 서버의 확장성 기능들을 다루는 고급 유저을 위핸 정보를 설명한다. 사용자 정의 데이터 타입, 함수를 포함하고 있다. | Part6은 SQL 커맨드와 클라이언트/서버 프로그램에 대한 레퍼런스를 포함하고 있다. 이 파트는 명렁 또는 프로그램에 의해 정렬된 구조화 정보로 다른 파트를 지원한다. | Part7은 PostgreSQL 개발자에게 유영한 정보를 설명한다. | . ",
    "url": "/docs/03_postgresql/00.preface/",
    
    "relUrl": "/docs/03_postgresql/00.preface/"
  },"2": {
    "doc": "Quick starts",
    "title": "Quick starts",
    "content": "레디스 퀵 스타트 가이드 . 레디스는 데이터베이스, 캐시, 스트리밍 엔진, 메세지 브로커 등등으로 사용될 수 있다. 아래 퀵 스타트 가이드는 특정 목적을 위한 레디스 사용법을 보여준다. | Data structure store | Document database | Vector database | . 사용자의 사용 시나리오와 잘 맞는 가이드를 선택해라. FAQ에서 자주 물어보는 질문과 답변을 찾을 수 있다. ",
    "url": "/docs/01_redis/0001.quick_starts/",
    
    "relUrl": "/docs/01_redis/0001.quick_starts/"
  },"3": {
    "doc": "What is PostgreSQL",
    "title": "What is PostgreSQL",
    "content": "PostgreSQL은 POSTGRES Version 4.2를 기반으로 하는 객체 관계형 데이터베이스 관리 시스팀(ORDBMS)이며 버클리의 캘리포니아 대학교 컴퓨터 과학과에서 개발되었다. POSTGRES는 이후에 몇몇 상업용 데이터베이스 시스템에서만 가능하던 많은 컨셉들을 개척했다. PostgreSQL은 원본 버클리 코드의 오픈소스 자손이다. SQL 표준의 많은 부분들과 다양한 최신 기능들을 제공하낟. | 복잡한 쿼리 | 외래키 | 트리거 | 업데이트 가능한 뷰 | 트랜젝션 무결성 | 다중버전 동시성 제어 | . 또한 PostgreSQL은 다양한 방법으로 사용자가 기능을 확장할 수 있다. 예를들어 . | 데이터 타입 | 함수 | 오퍼레이터 | 집계 함수 | 인덱스 메소드 | 프로시져 언어 | . 또한 PostgreSQL은 자유로운 라이센스로, 개인용/상업용/교육용 등에 목적이 상관없이 누구나 자유롭게 사용, 수정, 배포할 수 있다. ",
    "url": "/docs/03_postgresql/0001.what_is_postgresql/",
    
    "relUrl": "/docs/03_postgresql/0001.what_is_postgresql/"
  },"4": {
    "doc": "Data structure store",
    "title": "Develop with Redis",
    "content": "레디스 개발에 대해 알아본다. Quick starts . 빠르게 레디스를 시작하는 가이드 . Connect to Redis . 유저 인터페이스와 클라이언트 라이브러리를 사용하는 방법 . Understand Redis data types . 레디스가 지원하는 데이터 타입 오버뷰 . Interact with data in Redis . 쿼리, 트리거 함수, 트랜젝션, pub/sub을 사용해서 레디스의 데이터와 상호작용하는 방법 . User Redis . 레디스 개발자 가이드 . Redis reference . 명세, 프로토콜 . ",
    "url": "/docs/01_redis/000101.data_structure_store/#develop-with-redis",
    
    "relUrl": "/docs/01_redis/000101.data_structure_store/#develop-with-redis"
  },"5": {
    "doc": "Data structure store",
    "title": "Data structure store",
    "content": " ",
    "url": "/docs/01_redis/000101.data_structure_store/",
    
    "relUrl": "/docs/01_redis/000101.data_structure_store/"
  },"6": {
    "doc": "A Brief History of PostgreSQL",
    "title": "A Brief History of PostgreSQL",
    "content": "객체 관계형 데이터베이스 관리 시스템으로 알려진 PostgreSQL은 버클리의 캘리포니아 대학교에서 만들어진 POSTGRES 패키지로부터 파생되었다. 수십년의 개발을 거쳐 PostgreSQL은 현재 어디에서나 사용할 수 있는 가장 진보된 오픈소스 데이터베이스가 되었다. ",
    "url": "/docs/03_postgresql/0002.a_brief_history_of_postgresql%20copy/",
    
    "relUrl": "/docs/03_postgresql/0002.a_brief_history_of_postgresql%20copy/"
  },"7": {
    "doc": "A Brief History of PostgreSQL",
    "title": "The Berkeley POSTGRES Project",
    "content": "Michael Stonebraker 교수가 리드한 POSTGRES 프로젝트는 Defense Advaned Research Projects Agency(DARPA), Army Research Office(ARO), National Science Foundation(NFS), ELS Inc에서 지원하였다. 1986년에 시작되었다. 초기 컨셉은 ston86에서 볼 수 있고 rowe87에서 초기 데이터 모델에 대한 정의를 확인할 수 있다. 그 떄 당시의 룰 시스템 디자인은 ston87a에서 볼 있고 스토리니 매니저의 아키텍쳐와 이론적인 설명은 ston87b에서 볼 수 있다. POSTGRES는 이후러 여라 차례 릴리즈를 거쳤다. 첫 demoware 시스템은 1987에 동작을 시작했으며 1998 ACM-SIGMOD 컨퍼런스에서 선보였다. ston90a에서 볼 수 있는 버전1은 1989년 6월에 몇몇 외부 사용자들에 의해 릴리즈되었으며 첫번쨰 룰 시스템(ston98) 재디자인된 것은 ston90b에서 볼수 있으며 버전2가 1990년에 신규 룰 시스템과 함께 릴리즈되었다. 1991년에 발표된 버전3는 다중 스토리지 매니저, 향상된 쿼리 실행기, 룰 시스템 업데이트가 포함되었다. 대부분의 경우, Postgres95까지의 후속 릴리즈들은 안정성과 이식성에 주안점을 두었다. POSTGRES는 다양한 연구 및 생산 애플리케이션을 구현하기 위해 사용되었다. 금융 데이터 분석, 제트엔진 성능 모니터링 패키지, 소행성 트래킹 데이터베이스, 의료 정보 데이터베이스, 여러 지리 정보 시스템에 사용되었다. 또한 여러 대학들에서 교육용 도구로 많이 사용되었다. 마지막으로 Illustra Information Technologies(나중에 Informix에 합병되었으며 현재 IBM이 소유)가 상용화하였었다. 1992년 이후 POSTGRES는 Sequoia 2000 scientific computing project의 primary data manager가 되었다. 1993년 동안 외부 사요자 커뮤니티의 사이즈가 거의 두배로 늘었다. 데이터베이스 연구에 더 많은 투자를 위한 많은 양의 시간과 지원과 프로타타입 코드 관리가 필요한 것이 점점 더 명확해졌다. 이러한 지원 부담을 줄이기 위한 노력으로 Berkeley에선 POSTGRES 프로젝트를 공식적으로 4.2버전으로 중지했다. ",
    "url": "/docs/03_postgresql/0002.a_brief_history_of_postgresql%20copy/#the-berkeley-postgres-project",
    
    "relUrl": "/docs/03_postgresql/0002.a_brief_history_of_postgresql%20copy/#the-berkeley-postgres-project"
  },"8": {
    "doc": "A Brief History of PostgreSQL",
    "title": "Postgres95",
    "content": "1994년에 Andrew Yu와 Jolly Che은 POSTGRES에 SQL 언어 인터프리터를 추가했다. 버클리의 원본 POSTGRES 코드의 자손으로 오픈소스로써 세계에 Postgres95라는 새로운 이름으로 웹에 공개되었다. Postgres95 코드는 ANSI C로만 이루어졌으며 크기를 25%로 줄였다. 많은 내부적인 변경이 성능과 유지보수성을 향상시켰다. Wisconsin Benchmark가 비교한 바에 따르면 POSTGRES Version 4.2 대비 Postgres95 릴리즈 1.0.x는 거의 30~50%정도 빨랐다. 버그 수정 이외에도 주요 발전사항은 아래와 같다. | 쿼리 언어 PostQUEL이 SQL(서버에서 구현된)로 교체되었다.(인터페이서 라이브러리 libpq는 PostQUEL을 따서 네이밍되었다.) 서브쿼리는 PostgreSQL까지 지원되지 않았지만 Postgres95와 사용자 정의 SQL 함수를 사용해서 흉내낼 수 있었다. 집계함수는 재구현되었다. GROUP BY 쿼리 구문이 추가되었다. | 새로운 프로그램(psql)에서 GNU Readline을 사용하여 반응형 SQL 쿼리를 제공했다. 이전 모니터 프로그램을 대체했다. | libpqtcl이라는 새로운 프론트엔드 라이브러리가 추가되어 클라이언트 기반의 Tcl을 지원했다. 예를들어 pgclsh은 Postgres95 server에서 Tcl 프로그램 인터페이스로 새로운 Tcl 명렁을 제공한다. | The large-object interface was overhauled. The inversion large objects were the only mechanism for storing large objects. (The inversion file system was removed.) | The instance-level rule system was removed. Rules were still available as rewrite rules. | Postgres95 뿐만 아니라 일반 SQL 기능을 소개하는 짧은 튜토리얼이 소스코드와 함께 배포되었다. | BSD make 대신에 GNU make를 사용하여 빌드되었다.Postgres95는 unpatched GCC로 컴파일될 수 있다.(data alignment of doubles was fixed) | . PostgreSQL . 1996년이 되서 Postgres95라는 이름이 지속될 수 없을 것임이 명확해졌다. 그래서 본래 이름이였던 POSTGRES와 연관성이 있 고 최신 버전이 SQL 기능이 있음을 표현할 수 있는 PostgreSQL이라는 새로운 이름을 선택했다. 버전은 6.0 부터 시작함으로써 버클리 POSTGRES 프로젝트에서 사용된 번호 체계를 이어가게 하였다. 많은 사람들이 전통적이거나, 더 발음하기 쉽다는 이유로 여전히 Postgres(아주 드물게는 대문자로)로 사용한다. 이 이름은 nickname, alias로써 받아들여진다. Postgres95의 주요 쟁점이 기존 서버 코드의 문제를 인식하는 것이였다면 PostgreSQL은 모든 영역에서 특징과 기능을 강화하는 것으로 옴겨졌다. PostgreSQL에서 어떤점이 제기되었는지는 Appendix E에서 볼 수 있다. ",
    "url": "/docs/03_postgresql/0002.a_brief_history_of_postgresql%20copy/#postgres95",
    
    "relUrl": "/docs/03_postgresql/0002.a_brief_history_of_postgresql%20copy/#postgres95"
  },"9": {
    "doc": "Conventions",
    "title": "Conventions",
    "content": "다음과 같은 컨벤션이 사용된다. 대괄호([, ])은 선택적인 부분을 나타낸다. 중괄호({, })와 세로줄(|)은 반드시 하나를 선택해야됨을 의미한다. 점들(...)은 요소들이 반복되는 것을 의미한다. 괄호 등 다른 기호들은 문자 그대로 받아들이면 된다. 명확하게 하기위해서 SQL 명령어 앞에는 프롬프트 기호 =&gt;가 오고 쉘커맨드는 프롬프트 $가 온다. 일반적으로 프롬프트는 표시되지 않는다. 관리자(adiministrator)란 서버를 설치하고 운영하는 책임자를 의미한다. 사용자(user)는 PostgreSQL 시스템의 일정 부분을 사용하거나 또는 사용하길 원하는 누군가이다. 이 용어는 너무 제한적으로 해석되어선 안되고 시스템 관리 절차에 대해 고정된 방식을 따르지 않는다. ",
    "url": "/docs/03_postgresql/0003.conventions/",
    
    "relUrl": "/docs/03_postgresql/0003.conventions/"
  },"10": {
    "doc": "Futher Information",
    "title": "Further Information",
    "content": "이 도큐먼트 이외에도 PostgreSQL에 대한 다른 리소스들이 있다. Wiki . PostgreSQL Wiki는 프로젝트의 FAQ/TODO 리스트와 더 많은 토픽들에 대한 세부 정보가 있다. Web Site . PostgreSQL 웹사이트는 PostgreSQL의 생산성 향상을 위한 더 많은 정보와 최신 릴리즈에 대한 세부 내용이 있다. Mailing Lists . 메일링 리스트는 사용자의 질문과 답변이 있어 다른 사용자들의 경험을 공유하고 개발자들에게 컨택할 수 있는 좋은 장소이다. 자세한 내용은 PostgreSQL 웹사이트를 참고하라. YHourself! . PostgreSQL은 오픈소스 프로젝트이다. 따라서 지속적인 지원은 유저 커뮤니티에 달려있다. PostgreSQL 사용을 시작하게 되면 문서나 메일링 리스트를 통해 다른사람에게 도움을 요청하게 될 것이다. 이렇게 축적된 지식으로 메일링 리스트에 답변하고 프로젝트에 기여해라. 만약 도큐먼트에 없는 것에 대해 알게된다면 작성하고 기여해라. 만약 코드에 기능을 추가하게되면 그 것을 기여해라. ",
    "url": "/docs/03_postgresql/0004.futher_information/#further-information",
    
    "relUrl": "/docs/03_postgresql/0004.futher_information/#further-information"
  },"11": {
    "doc": "Futher Information",
    "title": "Futher Information",
    "content": " ",
    "url": "/docs/03_postgresql/0004.futher_information/",
    
    "relUrl": "/docs/03_postgresql/0004.futher_information/"
  },"12": {
    "doc": "Bug Reporting Guidelines",
    "title": "5. Bug Reforting Guidelines",
    "content": "PostgreSQL의 버그를 만약 찾게된다면 우리는 그것에 대해 전달받길 원한다. 버그 리포팅은 PostgreSQL을 더 안정적이게 만들 수 있는 중요한 부분이다. 왜냐면 아무리 주의룰 기울여도 PostgreSQL의 모든 부분이 모든 상황의 모든 플랫폼에서 정상 작동한다고 보장할 순 없다. 다ㅁ 소개하는 방식들은 사용자가 효과적으로 버그 리포트를 작성하는데 도움울 줄 것이다. 이것은 강제는 아니지만 따라준다면 모두에게 좋다. 모든 버그는 바로 수정되지 않는다. 버그가 명백하고 치명적이며 영향력이 크다면 누군가가 그것을 조사할 가능성이 높다. 버그가 발생하는지 확인하기 위해 새로운 버전으로 업데이트하라고 말할 수 도 있다. 또한 몇가지 주요 안건의 계획이 끝나기 전에 버그가 고쳐지지 않는 것을 결정할 수도 있다. 아니면 단순히 더 어렵고 중요한 아젠다가 있을 수도 있다. 만약 바로 도움이 필요하다면 상업 지원 계약을 검토해라. ",
    "url": "/docs/03_postgresql/0005.bug_reporting_guidelines/#5-bug-reforting-guidelines",
    
    "relUrl": "/docs/03_postgresql/0005.bug_reporting_guidelines/#5-bug-reforting-guidelines"
  },"13": {
    "doc": "Bug Reporting Guidelines",
    "title": "5.1. Identifying Bugs",
    "content": "버그를 리포트하기 전에 읽고, 또 한번 더 읽어서 실제로 수행할 수 있는지 확인해라. 만약 사용자가 무엇을 할 수 있고, 할 수 없는 지 문서가 명확하지 않다면 그 것도 리포트를 해라. 그것은 문서의 버그이다. 만약 문서에 기재된 내용과 다른 내용으로 프로그램이 동작한다면 그것은 버그이다. 그것은 아마 다음 항목에 포함되어 있겠지만 제한된 것은 아니다. | 프로그램에 문제가 발생했다는 OS 에러 메세지 또는 fetal signal로인해 프로그램이 종료되는 경우(disk full 메세지는 사용자가 고칠 수 있는 경우이므로 반례 중 하나) | 프로그램이 입력값이 대해 잘못된 출력을 만드는 경우 | 프로그램이 유효한 입력(문서에 정의된)을 거부하는 경우 | 알람이나 에러 메세지 없이 유효하지 않은 입력값을 받는 경우. 하지만 기존 방식에서의 확장, 호환성일 수 있다. | 지원하는 플랫폼에서 설명에 따라 PostgreSQL 컴파일, 빌드, 설치를 했을 때 실패하는 경우 | . ",
    "url": "/docs/03_postgresql/0005.bug_reporting_guidelines/#51-identifying-bugs",
    
    "relUrl": "/docs/03_postgresql/0005.bug_reporting_guidelines/#51-identifying-bugs"
  },"14": {
    "doc": "Bug Reporting Guidelines",
    "title": "Bug Reporting Guidelines",
    "content": " ",
    "url": "/docs/03_postgresql/0005.bug_reporting_guidelines/",
    
    "relUrl": "/docs/03_postgresql/0005.bug_reporting_guidelines/"
  },"15": {
    "doc": "Concepts",
    "title": "Concept",
    "content": "이스티오 시스템의 다양한 부분과 사용하고있는 추상화에 대해서 배운다. ",
    "url": "/docs/02_istio/01.concepts/#concept",
    
    "relUrl": "/docs/02_istio/01.concepts/#concept"
  },"16": {
    "doc": "Concepts",
    "title": "Concepts",
    "content": " ",
    "url": "/docs/02_istio/01.concepts/",
    
    "relUrl": "/docs/02_istio/01.concepts/"
  },"17": {
    "doc": "Traffic Management",
    "title": "Traffic Management",
    "content": "이스티오의 트래픽 라우팅 룰은 사용자가 서비스간 API 콜과 트래픽 흐름을 쉽게 컨트롤할 수 있게 해준다. 이스티오는 써킷 브레이커, 타임아웃, 리트라이같은 서비스 레벨의 설정을 단순화하며 퍼센트 기반의 트래픽 조절을 상요한 스테이지 롤아웃, 카나리 롤아웃, A/B 테스팅 같은 중요한 작업을 쉽게 설정할 수 있게 해준다. 또한 네트워크, 서비스로 인해 발생하는 장애로부터의 탄력적이게 운용할 수 있게 해주는 즉시 적용 가능한 신뢰성 기능들을 제공한다. 이스티오의 트래픽 매니지먼트 모델은 서비스와 같이 배포되는 엔보이 프록시로부터 제공된다. 메시 서비스에서 주고 받는 모든 트래픽은 엔보이로부터 프록시되고 사용자 서비스의 별도 수정 없이도 쉽게 컨트롤할 수 있게 해준다. 만약 이 가이드에서 설명한 기능이 어떻게 동작하는지 관심있다면, 이스티오 트래픽 매니저 구현과 관련된 더 자세한 내용을 아키텍쳐 오버뷰에서 볼 수 있다. 이 가이드 나머지 부분에선 이스티오의 트래픽 매니지먼트 기능에 대해 설명한다. ",
    "url": "/docs/02_istio/0101.traffic_management/",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/"
  },"18": {
    "doc": "Traffic Management",
    "title": "Introducing Istio traffic management",
    "content": "사용자의 메시안에서 트래픽을 컨트롤하기위해 이스티오는 모든 사용자의 서비스들과 그 서비스들이 가지는 엔트포인트에 대해서 알아야 한다. 서비스 레지스트리에 정보를 넣기 위해 이스티오는 서비스 디스커버리 시스템에 접속한다. 예를들어 만약 사용자가 이스티오를 쿠버네티스 클러스터에 설치했다면 이스티오는 클러스터내의 엔드포인트와 서비스들을 자동으로 감지한다. 서비스 레지시트리를 사용해서 엔보이는 관련 서비스로 트래픽을 전달한다. 대부분의 마이크로서비스 기반 애플리케이션은 서비스 트래픽을 핸들링하거나 또는 로드벨런싱등을 위해 개별 워크로드의 멀티 인스턴스를 가진다. 엔보이 프록시는 기본적으로 최소 요청 모델을 사용해서 서비스의 로드밸런싱 풀에 트래픽을 분산한다. 풀에 투 호스트가 랜덤으로 선택되어 더 적은 액티브 요청을 가지는 호스트로 라우팅된다. in this way the most heavily loaded host will not receive requests until it is no more loaded than any other host. 이스티오의 기본 서비스 디스커버리와 로드벨런싱은 서비스 메시를 가능하게 하지만 이것이 다는 아니다. 대부분의 사용자는 메시의 트레픽을 더 세밀하게 제어하고 싶어 한다. 사용자는 새로운 버전의 A/B 테스팅을 위해 트래픽을 특정 퍼센테이지로 지정하거나 또는 전체 서비스 인스턴스 중 특정 인스턴스들의 트래픽에 대한 특별한 로드벨런싱 룰을 적용하거나 등을 원할 수 있다. 이스티오는 이런 기능들을 트래픽 매니지먼트 API에서 트래픽 설정을 통하여 제공한다. 다른 이스티오 설정과 같이, yaml로 설정하는 쿠버네티스 커스텀 리소스 정의(CRDs)로 지정할 수 있다. 이 가이드의 남은 부분은 아래 나열된 트래픽 매니지먼트 API 리소스들을 설명하고 어떻게 하는지 알아본다. | Virtual services | Destination rules | Gateways | Service entires | Sidecars | . 이 가이드는 API 리소스에 포함되어있는 또한 네트워크 탄력성과 테스팅 기능도 살펴본다. ",
    "url": "/docs/02_istio/0101.traffic_management/#introducing-istio-traffic-management",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#introducing-istio-traffic-management"
  },"19": {
    "doc": "Traffic Management",
    "title": "Virtual services",
    "content": "버츄얼 서비스는 데스티네이션 룰과 함께 이스티오의 트래픽 라우팅 기능의 핵심이다. 버츄얼 서비스는 이스티오와 플랫폼에의해 제공되는 기본 연결 및 검색을 기반으로 리퀘스트를 이스티오 서비스 메시에 속해있는 서비스에 어떻게 라우트할지 설정할 수 있도록 제공한다. 개별 버츄얼 서비스는 우선순위를 가지는 여러 라우팅 룰들의 집합이고 이스티오는 가상 서비스로의 요청을 메시상의 실제 목적지와 매칭시킨다. 사용자의 메시에따라 여러개의 버츄얼 서비스가 필요할수도, 필요없을수도 있다. Why use virtual services? . 버츄얼 서비스는 이스티오의 트래픽 매니지먼트를 유연하고 강력하게 만들어주는 핵심 기능이다. 실제 구현된 목적지의 워크로드를 클라이언트가 전송하는 리퀘스트로부터 강력하게 디커플링한다. 또한 워크로드로 트래픽을 전송하기 위한 다양한 트래픽 라우팅 룰을 정의하는 다양한 방법을 제공한다. 왜 이것이 유용할까? 버츄얼 서비스가 없다면 엔보이는 최소 요청 방식 로드밸런싱 방식을 상요한 트래픽 분산을 모든 서비스 인스턴스를 대상으로 수행한다. You can improve this behavior with what you know about the workloads. 예를들어 일부 서비스 인스턴스는 다른 버전일 수 있다. 이럴 경우, A/B 테스팅 상황에서 다른 서비스 버전으로 가는 트래픽을 퍼센트 기반의 설정으로 라우팅을 조절하거나 또는 내부 유저들은 특정 인스턴스들에게 트래픽을 받을 수 있도록 할 수 있다. 버츄얼 서비스를 통해 트래픽을 받을 호스트들의 이름을 지정할 수 도 있다. 버츄얼 서비스에서 제공하고는 라우팅 룰을 사용해서 엔보이에게 버츄얼 서비스의 트래픽을 적절한 목적지에 전송하도록 설정할 수 있다. 라우팅 목적지는 전혀 다른 서비스이거나 또는 같은 서비스의 다른 버전이 될 수도 있다. 일반적인 유즈케이스는 서비스의 다른 버전들로 트래픽을 보내는 것이다. 만약 싱글 엔티티라고 가정하면 클라이언트는 버츄얼 서비스 호스트로 요청을 보내면 엔보이는 그 트래픽을 버츄얼 서비스 룰에 따라 다른 버전으로 보내는 방식이다. 예를들어 “트래픽의 20%는 신규 버전으로 보낸다” 또는 “특정 유저의 요청은 버전2의 서비스가 처리한다’ 등이다. 이러한 방식은 사용자가 점진적으로 퍼센트를 조절하여 신규 버전으로 트래픽을 가도록 하는 카나리 배포를 할 수있도록 해준다. 트래픽을 라우팅하는 것은 완벽하게 인스턴스를 배포하는것과 별개로 분리되어있다. 이것은 신규 버전 서비스 인스턴스의 숫자를 트래픽 라우팅 참조 없이 트래픽에 따라 스케일 업 또는 다운을 할 수 있게 해준다. 쿠버넷과 같은 컨테이너 오케스트레이션 플랫폼은 인스턴스 스케일링 기반으로 트래픽을 분배하는 방식만 지원하기 때문에 매우 복잡하다. 어떻게 버츄얼 서비스가 카나리 배포를 지원하는지에 대해 Canary Deployment using Istio 문서를 통해 더 자세히 알 수 있다. 또한 버츄얼 서비스는 이런 기능들을 제공한다 . | 단일 버츄얼 서비스에서 여러 애플리케이션 서비스를 컨트롤할 수 있다. 예를들어 쿠버네티스에 메시를 구축할 경우, 하나의 버츄얼 서비스에서 네임스페이스를 설정하고 그 네임스페이스에 속한 모든 서비스를 핸들링할 수 있다. 여러 실제 서비스를 하나의 버츄얼 서비스에 매핑하는 것은 특히 서비스를 사용하는 고객이 아무것도 모르는 상태에서 모놀리틱 애플리케이션을 마이크로서비스 환경으로 변환하는데 유용하다. 라우팅 룰을 사용해서 monolith.com을 호출하던 요청이 microservice A를 호출하도록 정의할수 있다. 이렇나 정보는 one of our examples below에서 확인할 수 있다. | [gateway]에서 인그레스, 이그레스 트래픽을 조정하는 트래픽 룰을 설정할 수 있다. | . 몇몇 경우에 이러한 기능들을 이용하기 위해서 데스티네이션 룰에 서비스의 서브셋들을 정의할 필요가 있다. 개별 오프젝트에 서비스 서브셋을 정의하고 대상별 정책을 정의하는것은 사용자가 버츄얼 서비스간에 이러한 정의들을 깔끔하게 재사용할 수 있게 해준다. 다음 섹션에서 데스테이션 룰을 사용하는 방법을 알아본다. ",
    "url": "/docs/02_istio/0101.traffic_management/#virtual-services",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#virtual-services"
  },"20": {
    "doc": "Traffic Management",
    "title": "Viertual service example",
    "content": "아래는 버츄얼 서비스로 특정 유저가 보내는 요청을 각기 다른 버전으로 전송시키는 버츄얼 서비스 정의이다. apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - match: - headers: end-user: exact: jason route: - destination: host: reviews subset: v2 - route: - destination: host: reviews subset: v3 . The hosts field . hosts 필드에서 버츄얼 서비스의 호스트들을 정의할 수 있다. 즉 사용자가 라우팅 룰을 적용할 수 있는 목적지이다. 여기 나열된 주소들은 클라이언트의 서비스 요청 대상이다. hosts: - reviews . 버츄얼 서비스의 호스트 이름엔 아이피, DNS name, or, depending on the platform, a short name (such as a Kubernetes service short name) that resolves, implicitly or explicitly, to a fully qualified domain name (FQDN). 또한 와일드 카드(“*”) 프리픽스를 사용해서 사용자가 하나의 라우팅 룰 셋으로 모든 매칭되는 서비스르 컨트롤할 수 있다. 버츄얼 서비스 호스트는 실제 이스티오의 서비스 레지스트리는 아니며 간단한 가상 목적지이다. 이것은 사용자가 메시상의 라우팅 엔트리가 없는 가상 호스트의 트래픽을 모델링할 수 있다. Routing roles . http 섹션은 버츄얼 서비스의 라우팅 룰을 정의한다. 라우팅 룰에선 조건에 만족하는지, HTTP/1.1 또는 HTTP2 인지, 호스트 필드에 나열된 목적지로 gRPC 트래픽을 보내는지 등을 설정할 수 있다. 또한 tcp, tls 섹션에선 TCP 및 unterminated TLS 트래픽을 설정할 수 있다. 라우팅 룰은 유즈케이스에 따라 조건을 사용해 어느 곳에 얼마나 트래픽을 전송하거나, 전송할지 설정하는 구성들로 이루어져있다. Match condition . 아래 예제의 첫번째 라우팅 룰은 match 필드로 조건을 정의한느 것으로 시작한다. 이 경우 모든 “jason” 유저의 모든 요청에 라우팅 룰이 적용되길 원하기 때문에 headers, end-user, exact 필드를 사용해서 적절한 요청을 선택한다. Destination . 라우트 섹션에서 destination 필드는 이 조건에 해댕하는 트래픽의 실제 목적지를 정의한다. 버츄얼 서비스의 host와는 다르게 이 목적지의 호스트는 이스티오의 서비스 레지스트리상에 존재하는 실제 목적지이여야하며 그렇지 않으면 엔보이는 트래픽을 어디로 보낼 지 알 수 없게 된다. 이러한 방식은 메시 서비스가 메시 서비스상에 ㅇ벗는 서비스 엔트리를 프록시할 수 있도록 해준다. 이 경우 쿠버네티스에서 사용하는 쿠버네티스 서비스 이름을 사용했다. route: - destination: host: reviews subset: v2 . 이 페이지의 예제에선 목적지 호스트의 이름으로 쿠버네티스의 short name을 사용했다. 룰이 평가될 때 이스티오는 호스트의 fully qualified name을 얻기 위한 라우팅 룰를 포함하고 있는 버츄얼 서비스의 네임스페이스를 기반으로 한 도메인 suffix를 추가한다. 사용자는 원하는 네임스페이스에 이 예제를 복사해서 사용해볼 수 있다. short name을 사용하는 것은 목적지 호스트와 버츄얼 서비스가 실제 같은 쿠버네티스 네임스페이스에 있을 떄 유효하게 동작한다. 쿠버네티스의 short name은 misconfiguration이 될 수 있기 떄문에 실제 프로덕션에선 fully qualified host name을 사용하는 것을 추천한다. destication 섹션에선 이 예제엇 v2 라는 이름을 사용한 것 처럼 사용자의 요청 조건을 매칭시킬 수 있는 쿠버네티스 서비스 서브셋을 지정할수도 있다. 이러한 서비스 서브셋을 정의하는 방식을 destinatio nrules에서 확인할 수 있다. Routing rule precedence . 라우팅룰은 위에서 아래로 순차적으로 평가된다. 버츄얼 서비스의 가장 첫 번째 룰은 가장 높은 우선순위를 가진다. In this case you want anything that doesn’t match the first routing rule to go to a default destination, specified in the second rule. Because of this, the second rule has no match conditions and just directs traffic to the v3 subset. - route: - destination: host: reviews subset: v3 . 적어도 하나의 매칭되는 경로를 항상 가져서 트래픽을 보장할 수 있도록 버츄얼 서비스의 마지막 규칙을 “no condition” 또는 가중치 기반 룰을 사용하는 것을 추천한다. More about routing rules . 위에서 기술하였듯이, 라우팅룰은 특정 트래픽 셋을 특정 목적지로 라우팅하기 위한 강력한 도구이다. 포트, 헤더 필드, URI 등 다양한 방식으로 트래픽의 매칭 조건을 정의할 수 있다. 예를들어 이 버츄얼 서비스는 사용자는 http://bookinfo.com 에서 더 큰 가상서비스의 일부인 것 처럼 사용자의 트래픽을 ratings, reviews 두 서비스로 분리한다. 버츄얼 서비스 룰은 요청하는 URI 기반으로 트래픽을 매칭시키고 적절한 서비스로 요청이 전송되도록 한다. apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: bookinfo spec: hosts: - bookinfo.com http: - match: - uri: prefix: /reviews route: - destination: host: reviews - match: - uri: prefix: /ratings route: - destination: host: ratings . 매칭 조건으론 동일 조건, prefix, regex 등의 조건들도 사용할 수 있다. 조건들을 AND 연산 하기 위해 같은 match 블록에 여러 조건들을 추가하거나 또는 같은 룰 안에 여러 match 블록을 넣어 OR 조건을 만들 수 있다. 또한 특정 가상 서비스에 여러 라우팅 룰을 추가할수도 있다. 이 것은 하나의 버츄얼 서비스에서 간단하거나 또는 복잡한 조건들을 설정할 수 있도록 만들어준다. 조건 필드와 가능한 값에 대한 내용은 HttpMatchRequest레퍼런스에서 찾을 수 있다. 조건을 사용할 때 트래픽을 가중치 기반으로 분배할 수 있다. 이것은 A/B 텟흐팅, 카나리 배포 등에 배우 유용하다. spec: hosts: - reviews http: - route: - destination: host: reviews subset: v1 weight: 75 - destination: host: reviews subset: v2 weight: 25 . 또한 라우팅 룰에서 트래픽을 조작할수 있다. 예를들어 . | 헤더를 추가하거나 삭제 | URL Rewrite | 목적지 호출에 대한 retry policy 설정 | . 추가 정보는 HttpRoute reference에서 확인할 수 있다. ",
    "url": "/docs/02_istio/0101.traffic_management/#viertual-service-example",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#viertual-service-example"
  },"21": {
    "doc": "Traffic Management",
    "title": "Destination rules",
    "content": "버츄얼 서비스와 함께, 데스티네이션 룰은 이스티오의 트래픽 라우팅 기능 중 핵심 기능이다. 목적지로 트래픽을 라우팅하기 위한 설정을 버츄얼 서비스에서 했따면 라우팅 룰은 목적지의 트래픽에 일어나는 현상에 대해 설정한다. 데스티네이션 룰은 버츄얼 서비스에서 라우팅 룰이 평가되고 난 이후, 실제 목적지에 적용된다. 데스티네이션 룰에선 이름이 있는 서비스들의 서브셋을 정의한다. 예를들어 버전별 서비스 인스턴스를 그룹화할 수 있다. 그리고 버츄얼 서비스에서 여러 서비스들의 서브셋을 사용하여 서비스 인스턴스들에 대한 다른 드래픽을 컨트롤할 수 있다. 또한 TLS security mode, circuit breaker 설정, 로드밸런싱 모델 과같은, 특정 서비스 서브셋 또는 전체 목적지 서비스가 호출될 때 엔보이의 트래픽 정책을 수정할 수 있다. Destination Rule reference에서 데스테이션 룰 옵션에 대한 세부 사항을 확인할 수 있다. Load balancing options . 이스티오는 기본 로드밸런싱 정책으로 최소 요청 방식을 적용해 요청을 가장 적게 받은 인스턴스가 요청을 받도록 한다. 아래의 모델을 추가로 지원하며, 특정 서비스 또는 서비스 서브셋으로의 요청을 위한 데스티네이션 룰에서 이를 설정할 수 있다. | Random : 풀에 있는 인스턴스들에게 랜덤하게 요청을 포워딩한다. | Weighted : 특정 퍼센트에 따라 풀에 있는 인스턴스들에게 요청을 포워딩한다. | rount robin : 각각의 인스턴스들을 순찾거으로 포워딩한다. | . 각각의 옵션에 대한 정보는 Envoy load balancing documentation에서 확인할 수 있다. Destination rule example . 아래 예제는 각기 다른 로드밸런싱 정책을 가지는 my-svc 목적지 서비스를 위한 3개의 다른 서브셋 설정 데스티네이션 룰이다. apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: my-destination-rule spec: host: my-svc trafficPolicy: loadBalancer: simple: RANDOM subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 trafficPolicy: loadBalancer: simple: ROUND_ROBIN - name: v3 labels: version: v3 . 각가의 서브셋은 한개 이상의 labels를 기반으로 정의되며 이는 쿠버네티스에서 팟과 같은 오브젝트들에게 붙이는 key/value 쌍이다. 이 라벨들은 다양한 버전을 구분하기 위해 쿠버네티스 서비스의 deployment의 메타데이터로써 적용된다. 이 데스티네이션 룰은 서브셋을 정의했을 뿐만아니라 목적지를 위한 모든 서브셋에 대한 기본 트래픽 정책과 하위 집합에서 재정의하는 특정 서브셋을 위한 정책이 설정되어 있다. subsets 필드에서 보다시피 기본 정책인 랜덤 로드밸런싱 정책이 v1, v3 서브셋에 정의된다. v2 정책에서, 라운드 로빈 로드밸런서가 설정되었다. ",
    "url": "/docs/02_istio/0101.traffic_management/#destination-rules",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#destination-rules"
  },"22": {
    "doc": "Traffic Management",
    "title": "Gateways",
    "content": "메시의 인바운드, 아웃바운드 트래픽을 관리하기 위해 게이트웨이를 사용할 수 있다. 이는 메시의 들어오고 나가는 트래픽을 정의한다. 게이트웨이 설정은 메시의 엣지에서 동작하는 독립형 엔보이 프록시들에 적용된다. 서비스 워크로드와 같이 실행되는 엔포이 사이드카 엔보이 프록시가 아니다. 쿠버네티스 인그레서 API와 같은 다른 진입 트래픽 컨트롤 시스템의 메커니즘과는 달리 이스티오의 게이트웨이는 이스티오의 트래픽 라우팅을 위한 강력하고 유연한 기능들을 사용할 수 있다. 노출 포트 설정, TLS 설정 과 같은 4-6 레이어 로드밸런싱 설정이 가능하기 때문이 이를 할 수 있다. 애플리케이션 계층의 트래픽 라우팅(L7)을 동일한 API 리소스에 추가하는 대신, 이스티오 버츄얼 서비스의 게이트웨이에 바인딩하면 기본적으로 게이트웨이 트래픽을 다른 데이터 플레인 트래픽 처럼 관리할 수 있다. 게이트웨이는 주로 인그레스 트래픽을 관리하기 위해 사용하지만, 이그레스 게이트웨이도 물론 가능하다. 이그리스 게이트웨이는 메시에서 나가는 트래픽의 출구 노드를 지정하고, 서비스가 사용할 수 있거나 또는 사용해야하는 외부 네트워크 엑세스를 제한할 수 있다. 또한 이그레스 트래픽 보안 설정을 활성화해서 메시에 보안 기능을 추가할 수 있다. 예를들어 내부 프록시를 구성할 수 있다. 이스티오는 미리 설정되어있는 게이트웨이 프록시 deployments(istio-ingressgateway, istio-egressgateway)를 사용할 수 있도록 제공하며 demo installation에서 제공하며 default profile에선 인그레스 게이트웨이가 설정되어있는 것을 볼 수 있다. 이러한 deployment를 게이트웨이에 적용하고 프록시를 설정, 배포해볼 수 있다. Gateway example . 아리 예제는 외부 HTTPS 인그레스 트래픽에 대한 게이트웨이 설정 예제이다. apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: ext-host-gwy spec: selector: app: my-gateway-controller servers: - port: number: 443 name: https protocol: HTTPS hosts: - ext-host.example.com tls: mode: SIMPLE credentialName: ext-host-cert . 이 게이트웨이 설정은 ext-host.example.com으로부터 오는 HTTPS, 포트 443으로 들어오는 트래픽을 허용하지만 별도의 트래픽 라우팅 기능은 없다. 라우팅을 설정하고 게이트웨이가 의도에 따라 동작하기 위해선 게이트웨이를 버츄얼 서비스에 바인딩 해야한다. 아래 예제처럼 버츄얼 서비스의 gateways 필드에서 할 수 있다. apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: virtual-svc spec: hosts: - ext-host.example.com gateways: - ext-host-gwy . 이제 버츄얼 서비스가 외부 트래픽에 대한 라우팅 룰을 설정할 수 있게 되었다. ",
    "url": "/docs/02_istio/0101.traffic_management/#gateways",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#gateways"
  },"23": {
    "doc": "Traffic Management",
    "title": "Service entires",
    "content": "이스티오에서 내부적으로 관리하는 서비스 레지스리에 엔트리를 추가하기 위해선 service entiry를 사용하면 된다. 서비스 엔트리를 추가하면 엔보이 프록시들은 트래픽을 마치 메시상의 서비스인 것 처럼 트래픽을 보낼 수 있다.서비스 엔트리를 설정하면 메시 외부에서 동작하는 서비스의 트래픽도 관리할 수 있게되며 다음 기능들을 포함한다. | web상의 api를 호출하거나 레거시 인프라 서비스들에게 트래픽을 전송하는 것 처럼 외부 목적지의 트래픽을 리다이렉트하거나 포워딩할 수 있다. | 외부 목적지에대한 retry, timeout, fault injection 정책을 정의할 수 있다. | VM을 메시에 추가함으로써 메시 서비스를 VM에서 운용할 수 있다. | . 모든 외부 서비스를 서비스 엔트리에 추가할 필요 없이, 메시 서비스로써 사용할 외부 서비스들만 서비스 엔트리에 추가하면 된다. 기본적으로 이스티오는 엔보이 프록시가 알 수 없는 서비스에 대한 요청은 통과하도록 한다. 이렇게 등록하지 않을 경우 이스티오에서 제공하는 목적지 트래픽 컨트롤 기능은 사용할 수 없다. Service entry example . 아래 예제는 ext-svc.example.com 외부 디펜던시를 이스티오의 서비스 레지스트리에 추가하는 예제이다. apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: svc-entry spec: hosts: - ext-svc.example.com ports: - number: 443 name: https protocol: HTTPS location: MESH_EXTERNAL resolution: DNS . hosts 필드를 사용해서 외부 리소스를 정의할 수 있으며 완전한 주소 또는 와일드카드 prefix를 사용한 도메인 이름을 사용할 수 있다. 메시의 다른 서비스에 대한 트래픽을 설정하는 것과 같은 방식으로, 보다 더 세부적인 방법으로 서비스 엔트리로 들어오는 트래픽을 정교하게 컨트롤하기위한 버츄얼 서비스, 데스티네이션 룰을 설정할 수 있다. 예를들어 아래 데스티네이션 룰은 서비스 엔트리에 선언한 외부 서비스인 ext-svc.example.com로 요청하는 것에 대한 TCP 커넥션 타임아웃을 조정하는 설정이다. apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: ext-res-dr spec: host: ext-svc.example.com trafficPolicy: connectionPool: tcp: connectTimeout: 1s . 더 자세한 설정은 Service Entiry reference에서 볼 수 있다. ",
    "url": "/docs/02_istio/0101.traffic_management/#service-entires",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#service-entires"
  },"24": {
    "doc": "Traffic Management",
    "title": "Sidecars",
    "content": "관련된 워크로드에 대한 모든 포트를 허용하거나 또는 메시에 도달하는 모든 워크로드 트래픽을 전달하는 등 이런 기능들을 설정하기 위해 이스티오는 엔보이 프록시를 설정한다. sidecar 설정에서 아래 항목들을 할 수 있다. | 엔보이 프록시가 허용할 프로토콜, 포트 셋을 정밀하게 제어 | 엔보이 프록시가 연결할 수 있는 서비스들을 제한 | . You might want to limit sidecar reachability like this in larger applications, where having every proxy configured to reach every other service in the mesh can potentially affect mesh performance due to high memory usage. 특정 네임스페이스의 모든 워크로드 또는 workloadSelector를 사용해서 특정 워크로드에 적용하기 위한 사이드카 설정을 정의할 수 있다. 예를들어 아래 사이드카 설정은 같은 이스티오 컨트롤 플레인과 같은 네임스페이스상에서 구동중인 서비스에 도달하는 모든 bookinfo 네임스페이스 상의 서비스들에 대한 사이드카 설정이다. apiVersion: networking.istio.io/v1alpha3 kind: Sidecar metadata: name: default namespace: bookinfo spec: egress: - hosts: - \"./*\" - \"istio-system/*\" . 더 자세한 것은 Sidecar reference를 참고해라 . ",
    "url": "/docs/02_istio/0101.traffic_management/#sidecars",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#sidecars"
  },"25": {
    "doc": "Traffic Management",
    "title": "Network resilience and testing",
    "content": "이스티오는 메시상에서 드래픽을 조정하는 것 뿐만 아니라 런타임에도 유동적으로 설정이 간으한 . ",
    "url": "/docs/02_istio/0101.traffic_management/#network-resilience-and-testing",
    
    "relUrl": "/docs/02_istio/0101.traffic_management/#network-resilience-and-testing"
  },"26": {
    "doc": "Security",
    "title": "Security",
    "content": "모놀리스 애플리케이션을 아토믹 서비스로 전환하는 것은 다양한 이점이 있다. 더 좋은 애자일 성과 확장성, 서비스 재사용성을 얻을 수 있다. 그러나 마이크로서비스에선 특정 보안 요구사항이 있다. | man-in-the-middle 공격을 방어하기위해 트래픽 인크립션이 필요하다. | 서비스 접근을 유연하게 제어하기 위해 mutual TLS와 세밀한 정책 제어가 필요하다. | 누가 언제 무엇을 했는지 식별하기 위해 감사 도구가 필요하다. | . 이스티오의 보안은 이러한 문제를 해결하기 위한 종합적인 보안 솔루션을 제공한다. 이 페이지에선 서비스들을 안전하게 하기 위해 이스티오의 어떤 보안 설정들을 사용하고 동작시킬 수 있는지 살펴본다. 특히 이스티오는 내, 외부간 데이터, 엔드포인트, 커뮤니케이션, 플랫폼 위협을 완화한다. 이스티오의 보안 기능은 강력한 identity, 정책, transparent TLS 암호화, 인증, 인가와 감사(AAA)를 제공하여 서비스와 데이터를 보호한다. 이스티오의 보안 목적은 . | 기본 보안 : 애플리케이션의 코드와 인프라의 변경 없이 | 심층 방어 : 여러 계층의 방어를 제공하기 위한 기존 보안 시스템과의 통합 | Zero-trust 네트워크 : 분산 네트워크상의 보안 솔루션 빌드 | . mutual TLS Migration docs를 방문해서 배포된 서비스에 이스티오 시큐리티 기능들을 적용할 수 있는 문서를 볼 수 있다. Security Tasks에서 세부적인 시큐리티 기능 소개들을 볼 수 있다. ",
    "url": "/docs/02_istio/0102.security/",
    
    "relUrl": "/docs/02_istio/0102.security/"
  },"27": {
    "doc": "Security",
    "title": "High-level architecture",
    "content": "이스티오의 시큐리티는 여러 컴포넌트들로 이루어져 있다. | 인증기관(CA)의 키와 인증서 관리 | 설정 API 서버로 프록시에 아래 사항들을 배포 . | 인증 정책 | 인가 정책 | 보안 네이밍 정보 | . | | . ",
    "url": "/docs/02_istio/0102.security/#high-level-architecture",
    
    "relUrl": "/docs/02_istio/0102.security/#high-level-architecture"
  },"28": {
    "doc": "00.etc...",
    "title": "00.etc...",
    "content": " ",
    "url": "/docs/99_etc",
    
    "relUrl": "/docs/99_etc"
  },"29": {
    "doc": "Home",
    "title": "rura Dev",
    "content": " ",
    "url": "/#rura-dev",
    
    "relUrl": "/#rura-dev"
  },"30": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"31": {
    "doc": "01.Redis",
    "title": "01.Redis",
    "content": ". | 2024.11 작성 시작 | . ",
    "url": "/docs/01_redis",
    
    "relUrl": "/docs/01_redis"
  },"32": {
    "doc": "02.Istio",
    "title": "02.Istio",
    "content": ". | 2024.03 작성 시작 | . ",
    "url": "/docs/02_istio",
    
    "relUrl": "/docs/02_istio"
  },"33": {
    "doc": "03.PostgreSQL",
    "title": "03.PostgreSQL",
    "content": ". | 2024.04 작성 시작 | . ",
    "url": "/docs/03_postgresql",
    
    "relUrl": "/docs/03_postgresql"
  }
}
